- cm.rkt application includes racket stack trace, no es muy bien

- look over equality checking
    -- perhaps allow custom equality functions

-- `static` keyword
    -- like `def` except only defines a variable once
        --- equivalent to `if not defined? "x" then def x := val else void`
    -- static x := val
    -- defun will behave in a static manner
    -- perhaps make it so that each file that imports "a.cm" gets their
        own bindings; a `def x := 5` in "a.cm" will have a different reference for
        each file that imports it.

- figure out how to turn operators neatly into functions

- more general use macros?
    #:defop:{a}+={b} set a := a + b
    c += 2

- std.cm
    -- append_map
    -- filter_map
    -- partition
    -- shuffle
    -- sort

- function composition
    -- {: filter | compose not f | vs}

- `letrec` `var` `args`
    -- like `defun` but `var` can only be accessed within scope.
    letrec f (int x, bool b) :=
      code...
    in
      f:3//

- testing utility
    -- work in progress
