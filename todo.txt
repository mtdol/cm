. figure out how to get lex to accept strings with \" in them
. standardized testing (always could use more)
. how exactly should type system work

. printf (print + format)
. implement: format, slice, match, fun?
. implement def, let, values, lam
. look into error handling system
. fun keyword as shorthand for def and lambda


later...

. struct dataatype
. load
    - loads both racket modules and cm ones
    - takes a string or list of strings
    - start strings with 'f:' to indicate file locations
. evalp
    - evaluates racket procedures
    - takes a proc name (string) and returns the results of the call as a string
    - prefix racket var names with 'v:'
    
. installer (linux and windows)
    - look up racket distro info



# "cond" expression
fun fact n =
    | n < 2 -> 1 
    else n * (fact : sub1 : n).

# aka: def last_item = lam lst = 
fun last_item lst =
    match lst
    | null -> error "List was empty!"
    | h, null -> h
    | h, t -> last_item : t
    | _ -> error "Not a list!"
    end.

# creates a list of all positive values
fun acc_pos lst =
    match lst
    | h, t when pos? : h -> h, (acc_pos : t)
    | h, t -> acc_pos : t
    | null -> null
    end.

