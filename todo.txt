. figure out how to get lex to accept strings with \" in them
. standardized testing (always could use more)
. how exactly should type system work

. printf (print + format)
. implement: format, slice, match
. implement values
. look into error handling system
. defun keyword as shorthand for def and lambda


later...

. struct datatype
. load
    - loads both racket modules and cm ones
    - takes a string or list of strings
    - start strings with 'f:' to indicate file locations
. evalp
    - evaluates racket procedures
    - takes a proc name (string) and returns the results of the call as a string
    - prefix racket var names with 'v:'
    
. installer (linux and windows)
    - look up racket distro info


# aka: def last_item = lam lst = 
defun last_item lst =
    match lst
    | null -> error "List was empty!"
    | h, null -> h
    | h, t -> t : last_item
    | _ -> error "Not a list!"
    end.

# creates a list of all positive values
defun acc_pos lst =
    match lst
    | h, t when h : pos? -> h, (t : acc_pos)
    | h, t -> t : acc_pos
    | null -> null
    end.


# struct forms
#

# declaration of type
typedef St = int a, b, string c;.

# creating an instance
struct St (4, 7.5, "stuff").

# guard
lam struct St x = x.

# question
struct? St x.

# match case
| struct St (a, b, c) -> a.

#apply list operator
appl f 3,4,5;
# is equal to
5 : 4 : 3 : f

# null argument lambda, called with appl
def oneplustwo = lam null = 1 + 2
appl oneplustwo null
