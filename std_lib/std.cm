--- Macros
--------------------------------

-- macro that yields nothing
#:def:empty{}

-- macro that returns what it is given with arguments flattened out
#:def:flatten{v|REST} v {flatten REST}
#:def+:flatten{v} v
#:def+:flatten{} {empty}

-- nested comment
#:def:--{REST} {empty}
#:def+:--{} {empty}

#:def:vari{op|v|REST} ((v) op {vari op|REST})
#:def+:vari{op|v} (v)

-- code block
#:def:%{v|REST} ((v) comma {% REST})
#:def+:%{v} ((v) comma void)
#:def+:%{} void

-- wraps and builds a list
#:def:list{v|REST} ((v), {list REST})
#:def+:list{v} ((v);)
#:def+:list{} ()

-- apply args to function
#:def::{f|REST} (appl f {list REST})
#:def+::{f} (:>f)

-- only defines if the given var is defined else returns void
#:<def:defcheck{guard|var}
if defined? {string var} then void else def guard var
>:#

#:def:when{guard|result} (if (guard) then (result) else void) 
#:def:unless{guard|result} (if (guard) then void else (result))

-- multi-argument let
#:def:let{var|val|REST} let var := (val) in {let REST}
#:def+:let{var|val} let var := (val)  


-- checks that the types of items in REST equal
#:<def:assert_types={op|types|REST}
if not ({_assert_types=_aux types | REST}) 
    then error 
        {list "CONTRACT"
            | {: format
                | "Types for ~2 must be one of ~1:\n~3"
                | {list string (types) | op | string {list REST}}}}
    else
    -- user code after this
>:#
#:<def:_assert_types=_aux{types|a|REST}
{: ormap | lambda typ := typ = type (a) | types} and
    {_assert_types=_aux types|REST} 
>:#
#:<def+:_assert_types=_aux{types|a}
{: ormap | lambda typ := typ = type (a) | types}
>:#


--- IO
------------------------------

-- allows print to be used like a function
defun print2 v := print v. 
-- prints and yields void
defun sprint v := (print v) comma void. 
-- pretty print
defun pprint vs :=
    match vs 
    | () -> void 
    | v, t -> (@ v) comma (pprint:t)
    | v -> @ v
    end.


--- Math, lists
------------------------------

#:def:_number{} types ("int", "float";)


defun number? v :=
    let t := type v in
        t = "int" or t = "float".

defun add ({_number} n1, {_number} n2) :=
    {assert_types= "add"|{list type n1}|n1|n2} 
    n1 + n2.
defun sub ({_number} n1, {_number} n2) :=
    {assert_types= "sub"|{list type n1}|n1|n2} 
    n1 - n2.
defun mult ({_number} n1, {_number} n2) :=
    {assert_types= "mult"|{list type n1}|n1|n2} 
    n1 * n2.
defun div (float n1, float n2) :=
    n1 / n2.
defun exp ({_number} n1, {_number} n2) :=
    n1 ^ n2.


defun add1 {_number} n :=
    if type n = "int" then n + 1 else n + 1.0.
defun sub1 {_number} n :=
    if type n = "int" then n - 1 else n - 1.0.
defun zero? {_number} n :=
    if type n = "int" then n = 0 else n = 0.0.
defun pos? {_number} n :=
    if type n = "int" then n > 0 else n > 0.0.
defun neg? {_number} n :=
    if type n = "int" then n < 0 else n < 0.0.
defun one? {_number} n :=
    if type n = "int" then n = 1 else n = 1.0.
defun even? int n :=
    n % 2 = 0.
defun odd? int n :=
    n % 2 = 1.

defun to_int n := int n.
defun to_float n := float n.
defun to_string n := string n.
defun to_bool n := bool n.

-- maps f onto all members of list lst
defun map (fun f, list lst) := 
    | null? lst -> null 
    else (f:`lst), {: map | f | ~lst}//

-- returns a list with only the elements that are true according to f
defun filter (fun f, list lst) := 
    | null? lst -> null 
    | f:`lst -> `lst, {: filter | f | ~lst}
    else {: filter | f | ~lst}//

-- int | float -> int | float
defun max (n1, n2) :=
    if n1 > n2 then n1 else n2.

-- int | float -> int | float
defun min (n1, n2) :=
    if n1 < n2 then n1 else n2.


defun reverse list xs :=
    let aux := defun _aux_ (xs, acc) :=
        match xs
        | () -> acc
        | x, t -> {: _aux_ | t | x, acc}
        end
    in
        {: aux | xs | ()}//

defun append list lsts :=
    let f := lambda lst, acc :=
        {assert_types= "append"|{list "list"}|lst}
        {: foldl
            | lambda elem, acc :=
                elem, acc
            | acc
            | lst}
    in
        reverse : {: foldl | f | () | lsts}//

-- simple range, no iterator, just returns a list
defun range (int n1, int n2) :=
    let aux := defun _aux_ (n1, n2) :=
        {% 
          def _v_ := ()
          | while {iter {: iter_range|n2|n1}} 
                do set _v_ := (:>iter_get, _v_) 
        } comma _v_
    in
        | n1 > n2 -> {: aux|n1+1|n2+1}
        else {: aux|n1-1|n2-1}//

defun foldl (fun f, dynamic acc, list vs) :=
    match vs
    | () -> acc
    | v, t -> 
        let acc2 := {: f | v | acc} in
            {: foldl | f | acc2 | t}
    end//

defun foldr (fun f, dynamic acc, list vs) :=
    {: foldl | f | acc | reverse:vs}//

defun ormap (fun f, list vs) :=
    match vs
    | () -> false
    | v, vs when bool (f:v) -> true
    | _, vs -> {: ormap|f|vs}
    end//

defun andmap (fun f, list vs) :=
    match vs
    | () -> true
    | v, vs when not bool (f:v) -> false
    | _, vs -> {: andmap|f|vs}
    end//

-- ?, list -> bool | list
defun member (dynamic elem, list vs) :=
    match vs
    | () -> false
    | v, vs when v == elem -> vs 
    | _, vs -> {: member | elem | vs}
    end//

-- ?, list -> bool
defun member? (dynamic elem, list vs) :=
    list? {: member | elem | vs}//


--- Iterators, Generators
--------------------------------

-- generates a string that is undefined when treated as a variable
defun gen_undefined (string prefix, string module) := 
    {%
      def _v_ := 0
    | while defined? {list set _v_ := gensym prefix | module} do void
    } comma _v_
    //

-- eof will signal the end of the iteration
#:def:iter{a} (a) !== eof

def _seed := 0.
def _active? := false.

-- if the iter is active then iters with delta, else returns void
defun iter (fun delta) :=
    if _active? then
        set _seed := delta : _seed
    else
        eof//

defun iter_init (dynamic val) :=
    {% set _active? := true | set _seed := val} comma val//

defun iter_open? () :=
    _active?//

defun iter_get () :=
    _seed//

-- closes the iterator and returns eof
defun iter_term () :=
    {% set _active? := false} comma eof//

-- iterative range function
defun iter_range (int n1, int n2) :=
    -- readjust indexes and open iter
    | not :>iter_open? -> 
        -- iter stays closed
        | n1 = n2 -> eof
        else iter_init:n1
    | n1 < n2 -> 
        | :>iter_get = n2 - 1 -> :>iter_term
        else iter:add1
    -- n1 > n2
    else
        | :>iter_get = n2 + 1 -> :>iter_term
        else iter:sub1//


--- String funcs
--------------------------------

-- function form of the substring functionality of the index keyword
defun substring (string s, int i1, int i2) :=
    index s (i1,i2;).

defun string_ref (string s, int i) :=
    index s i.

defun concatenate (string s1, string s2) :=
    s1 $ s2.

defun string_length string s :=
    length s.

-- turns the string into a list of length 1 substrings
defun string_to_list string s :=
    match s
    | "" -> ()
    | _ -> (index s 0), (string_to_list : (index s (1, length s;)))
    end.

-- concatenates all of the elems in the list into a single string
defun list_to_string list ss :=
    match ss
    | () -> ""
    | s, t -> s $ (list_to_string:t)
    end.

-- replaces all instances of target substring with rep
defun string_replace (string str, string targ, string rep) :=
    if length str < length targ
    then str
    else
        if 
            str::(0, length targ;) = targ
        then 
            let str2 := str::(length targ, length str;) in
               rep $ {: string_replace | str2 | targ | rep} 
        else
            -- get first char
            let c := str::0 in
            -- get rest of string
            let str2 := str::(1, length str;) in
            c $ {: string_replace | str2 | targ | rep}//
               
-- takes a string of form "~1 ~2 ~3 ~1" and turns it into "v1 v2 v3 v1"
defun format (string str, list vs) :=
    let aux := defun _aux_ (str, vs, i) := 
        match vs
        | () -> str
        | v, t -> 
            let str2 := {: string_replace | str | "~" $ i | v} in
                {: _aux_ | str2 | t | add1:i}
        end
    in
        {: aux | str | vs | 1}//


--- Hashmap
--------------------------------

defun list_to_hash list ms :=
    {: foldl 
        | lam m,h := hash_set h (`m) (~m)
        | make_hash ()
        | ms}. 

defun list_to_mutable_hash list ms :=
    {: foldl 
        | lam m,h := (hash_set h (`m) (~m)) comma h
        | make_hash "mutable"
        | ms}. 


--- System
--------------------------------

match system_type
| "windows" -> (eval "#:def:win{} true") comma void
| "macosx" -> (eval "#:def:mac{} true") comma void
| "unix" -> (eval "#:def:unix{} true") comma void
| _ -> void
end.

-- cds only if the directory exists
defun cd2 string s :=
    if dir_exists? s 
    then 
        cd s 
    else 
        error ("SYSTEM", ("Dir "$s$" does not exist.");).

-- pretty print ls of current dir
defun lsc () :=
    pprint:(ls ".").
defun cdc () :=
    (cd "").

-- display contents of file
defun catf f :=
    pprint:(getlinesf f).
