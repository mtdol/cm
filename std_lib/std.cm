----
---- Standard Library
----
-- Matthew Dolinka

--- Macros
--------------------------------

-- macro that yields nothing
#:def:empty{}

-- macro that returns what it is given with arguments flattened out
#:def:flatten{v|REST} v {flatten REST}
#:def+:flatten{v} v
#:def+:flatten{} {empty}

-- nested comment
#:def:--{REST} {empty}
#:def+:--{} {empty}

#:def:vari{op|REST} ({_vari_aux op|REST}) 
#:def:_vari_aux{op|v|REST} (v) op {_vari_aux op|REST}
#:def+:_vari_aux{op|v} (v)

-- code block
#:def:%{v|REST} ((v) comma {% REST})
#:def+:%{v} ((v) comma void)
#:def+:%{} void

-- prints all given args and yields void
#:def:@{v|REST} (@ (v)) comma {@ REST}
#:def+:@{v} ((@ (v)) comma void)
#:def+:@{} void

-- wraps and builds a list
#:def:list{v|REST} ((v), {list REST})
#:def+:list{v} ((v);)
#:def+:list{} ()

-- apply args to function
#:def::{f|REST} (appl f {list REST})
#:def+::{f} (:>f)

-- only defines if the given var is defined else returns void
#:<def:defcheck{guard|var}
if defined? {string var} then void else def guard var
>:#

#:def:when{guard|result} (if (guard) then (result) else void) 
#:def:unless{guard|result} (if (guard) then void else (result))

-- multi-argument let
#:def:let{var|val|REST} let var := (val) in {let REST}
#:def+:let{var|val} let var := (val)  


-- checks that the types of items in REST equal
#:<def:assert_types={op|types|REST}
if not ({_assert_types=_aux types | REST}) 
  then error 
      {list "CONTRACT"
          | {: format
              | "Types for ~2 must be one of ~1:\n~3"
              | {list string (types) | op | string {list REST}}}}
  else
  -- user code after this
>:#
#:<def:_assert_types=_aux{types|a|REST}
{: ormap | lambda typ := typ = type (a) | types} and
  {_assert_types=_aux types|REST} 
>:#
#:<def+:_assert_types=_aux{types|a}
{: ormap | lambda typ := typ = type (a) | types}
>:#

--- Errors
------------------------------

-- allows `Error` struct to be indexed
typedef Error := string id, string message;//


--- IO
------------------------------

-- allows print to be used like a function
defun print2 (v) := print v// 
-- prints and yields void
defun sprint (v) := (print v) comma void// 
-- pretty print
defun pprint (vs) :=
  match vs 
  | () -> void 
  | v, vs -> (@ v) comma (pprint:vs)
  | v -> (@ v) comma void
  end//


--- Math, lists
------------------------------

-- shorthand for number types to be used with `types`
#:def:number{} ("int", "float";)


defun number? (v) :=
  let t := type v in
      t = "int" or t = "float"//

defun func.add (types {number} n1, types {number} n2) :=
  {assert_types= "add"|{list type n1}|n1|n2} 
  n1 + n2//
defun func.sub (types {number} n1, types {number} n2) :=
  {assert_types= "sub"|{list type n1}|n1|n2} 
  n1 - n2//
defun func.mult (types {number} n1, types {number} n2) :=
  {assert_types= "mult"|{list type n1}|n1|n2} 
  n1 * n2//
defun func.div (float n1, float n2) :=
  n1 / n2//
defun func.exp (types {number} n1, types {number} n2) :=
  n1 ^ n2//

defun func.and (bool b1, bool b2) :=
  b1 and b2//
defun func.or (bool b1, bool b2) :=
  b1 or b2//
defun func.xor (bool b1, bool b2) :=
  b1 xor b2//
defun func.not (bool b) :=
  not b//

defun add1 (types {number} n) :=
  if type n = "int" then n + 1 else n + 1.0//
defun sub1 (types {number} n) :=
  if type n = "int" then n - 1 else n - 1.0//
defun zero? (types {number} n) :=
  if type n = "int" then n = 0 else n = 0.0//
defun pos? (types {number} n) :=
  if type n = "int" then n > 0 else n > 0.0//
defun neg? (types {number} n) :=
  if type n = "int" then n < 0 else n < 0.0//
defun one? (types {number} n) :=
  if type n = "int" then n = 1 else n = 1.0//
defun even? int n :=
  n % 2 = 0//
defun odd? int n :=
  n % 2 = 1//

defun func.int? (dynamic v) :=
  int? v//
defun func.float? (dynamic v) :=
  float? v//
defun func.string? (dynamic v) :=
  string? v//
defun func.bool? (dynamic v) :=
  bool? v//
defun func.list? (dynamic v) :=
  list? v//
defun func.pair? (dynamic v) :=
  pair? v//
defun func.void? (dynamic v) :=
  void? v//
defun func.eof? (dynamic v) :=
  eof? v//
defun func.fun? (dynamic v) :=
  fun? v//
defun func.struct? (string label, dynamic v) :=
  struct? (var label) v//

-- spits back what you give it
defun value (dynamic v) := v//

defun abs (types {number} n) :=
  if neg?:n then -n else n//

defun to_int (v) := int v//
defun to_float (v) := float v//
defun to_string (v) := string v//
defun to_bool (v) := bool v//

defun func.head (pair v) := head v//
defun func.tail (pair v) := tail v//
defun car (v) := func.head:v//
defun cdr (v) := func.tail:v//


-- list questions
--

-- asks if vs is a list and all elements in vs are of the same type
defun homogeneous_list? (dynamic vs) :=
  | list? vs ->
    | null? vs -> true
    else 
      let typ := type `vs in
        {: andmap | lambda elem := type elem = typ | vs}
  else false//

defun list_of_type? (dynamic vs, string typ) :=
  | homogeneous_list?:vs ->
    | null? vs -> true
    else 
      type `vs = typ
  else false//

defun int_list? (dynamic vs) :=
  {: list_of_type? | vs | "int"}//

defun float_list? (dynamic vs) :=
  {: list_of_type? | vs | "float"}//

defun string_list? (dynamic vs) :=
  {: list_of_type? | vs | "string"}//

defun bool_list? (dynamic vs) :=
  {: list_of_type? | vs | "bool"}//

defun fun_list? (dynamic vs) :=
  {: list_of_type? | vs | "fun"}//


-- functions and math
--

-- maps f onto all members of list lst
defun map (fun f, list vs) := 
  match vs
  | () -> ()
  | v, vs -> (f:v), {: map | f | vs}
  end//

-- returns a list with only the elements that are true according to f
defun filter (fun f, list vs) := 
  match vs
  | () -> ()
  | (? v f), vs -> v, {: filter | f | vs}
  | _, vs -> {: filter | f | vs}
  end//

-- int | float -> int | float
defun max (types {number} n1, types {number} n2) :=
  {assert_types= "max"|{list type n1}|n1|n2} 
  if n1 > n2 then n1 else n2//

-- int | float -> int | float
defun min (types {number} n1, types {number} n2) :=
  {assert_types= "min"|{list type n1}|n1|n2} 
  if n1 < n2 then n1 else n2//

-- generalized max func
--
-- (any -> int | float) -> any
defun maxf (fun f, dynamic v1, dynamic v2) :=
  if f:v1 < f:v2 then
      v2
  else
      v1//

defun minf (fun f, dynamic v1, dynamic v2) :=
  if f:v1 > f:v2 then
      v2
  else
      v1//

defun reverse list xs :=
  letaux reverse
  | xs := xs
  | acc := ()
  in
    match xs
    | () -> acc
    | x, t -> {: reverse | t | x, acc}
    end//

defun append (list lsts) :=
  let f := lambda lst, acc :=
      {assert_types= "append"|{list "list"}|lst}
      {: foldl
          | lambda elem, acc :=
              elem, acc
          | acc
          | lst}
  in
      reverse : {: foldl | f | () | lsts}//

defun flatten (list lsts) :=
  match lsts
  | () -> ()
  | list lst, lsts -> {: append | {list (flatten:lst) | (flatten:lsts)}}
  | elem, lsts -> elem, (flatten:lsts)
  end//

-- simple range, no iterator, just returns a list
defun range (int n1, int n2) :=
  letrec range (n1, n2) :=
    {% 
      def _v_ := ()
      | while {iter {: iter_range|n2|n1}} 
            do set _v_ := (:>iter_get, _v_) 
    } comma _v_
  in
    | n1 > n2 ->
      {: range|n1+1|n2+1}
    else
      {: range|n1-1|n2-1}//

defun foldl (fun f, dynamic acc, list vs) :=
  match vs
  | () -> acc
  | v, t -> 
      let acc2 := {: f | v | acc} in
          {: foldl | f | acc2 | t}
  end//

defun foldr (fun f, dynamic acc, list vs) :=
  {: foldl | f | acc | reverse:vs}//

defun ormap (fun f, list vs) :=
  match vs
  | () -> false
  | v, vs when bool (f:v) -> true
  | _, vs -> {: ormap|f|vs}
  end//

defun andmap (fun f, list vs) :=
  match vs
  | () -> true
  | v, vs when not bool (f:v) -> false
  | _, vs -> {: andmap | f | vs}
  end//

-- ?, list -> bool | list
defun member (dynamic elem, list vs) :=
  match vs
  | () -> false
  | v, vs when v == elem -> vs 
  | _, vs -> {: member | elem | vs}
  end//

-- ?, list -> bool
defun member? (dynamic elem, list vs) :=
  list? {: member | elem | vs}//

-- removes the item elem from the list vs
defun remove (dynamic elem, list vs) :=
  match vs
  | () -> ()
  | v, vs when elem == v -> {: remove | elem | vs}
  | v, vs -> v, {: remove | elem | vs}
  end//

-- applies f to each integer in [n1 n2)
defun build_list_range (int n1, int n2, fun f) :=
  {: foldl 
      | lambda elem, acc :=
          (f:elem), acc
      | ()
      | 
          -- so we don't have to reverse the resulting list,
          -- just alter the indices
          \| n1 >= n2 ->
              {: range | n2 + 1 | n1 + 1}
          else 
              {: range | n2 - 1 | n1 - 1}
  }// 

-- applies f to each integer [0 n)
defun build_list (int n, fun f) :=
  | neg?:n ->
      error {list "CONTRACT" 
          | "Arg `n` to `build_list` must be non-negative."}
  else
      {: build_list_range | 0 | n | f}//

-- returns the index in `vs` where `f` is true,
-- returns `false` if no such indexes exist
defun index_where (list vs, fun f) :=
  letaux index_where
  | vs := vs
  | f := f
  | i := 0
  in
    match vs
    | () -> false
    | v, vs when f:v -> i
    | v, vs -> {: index_where | vs | f | add1:i}
    end//

-- returns the index in `vs` where `v` == `elem`
defun index_of (list vs, dynamic elem) :=
  {: index_where | vs | lambda x := x == elem}//

-- gets the last element of `vs`
defun last (list vs) :=
  match vs
  | () -> error {list "CONTRACT"|"List must be non-empty."}
  | v, () -> v
  | v, vs -> last:vs
  end//

-- updates the element at positions `is` with `updater`
defun list_update (list vs, ? is int_list?, fun updater) :=
  letaux list_update
  | vs := vs
  | is := is
  | updater := updater
  | curr := 0
  in
    match vs
    | () -> ()
    | v, vs when member?:curr:is -> 
      updater:v, {: list_update | vs | is | updater | add1:curr}
    | v, vs -> 
      v, {: list_update | vs | is | updater | add1:curr}
    end//

defun list_set (list vs, ? is int_list?, dynamic elem) :=
  {: list_update | vs | is | lambda _ := elem}//

-- returns the number of elements for which `f` yields true.
defun count (list vs, fun f) :=
  letaux count 
  | vs := vs
  | f := f
  | n := 0
  in
    match vs
    | () -> n
    | v, vs when f:v -> {: count | vs | f | add1:n}
    | v, vs -> {: count | vs | f | n}
    end//

-- returns true if there are duplicate elements in `vs`
defun duplicates? (list vs) :=
  let h := make_hash {list "mutable"} in
    {: ormap 
      | lambda elem :=
          if hash_has_key? h elem
          then
            true
          else (hash_set h elem void) comma false
      | vs}//

-- removes duplicate elements from `vs`
defun remove_duplicates (list vs) :=
  let h := make_hash {list "mutable"} in
    {: filter 
      | lambda elem :=
          if hash_has_key? h elem
          then
            false
          else (hash_set h elem void) comma true
      | vs}//

--- Iterators, Generators
--------------------------------

-- generates a string that is undefined when treated as a variable
defun gen_undefined (string prefix, string module) := 
  {%
    def _v_ := 0
  | while defined? {list set _v_ := gensym prefix | module} do void
  } comma _v_
  //

-- eof will signal the end of the iteration
#:def:iter{a} (not eof? (a))

def _seed := 0//
def _active? := false//

-- if the iter is active then iters with delta, else returns eof
defun iter (fun delta) :=
  if _active? then
      set _seed := delta : _seed
  else
      eof//

defun iter_init (dynamic val) :=
  {% set _active? := true | set _seed := val} comma val//

defun iter_open? () :=
  _active?//

defun iter_get () :=
  _seed//

defun iter_set (dynamic val) :=
  set _seed := val//

-- closes the iterator and returns eof
defun iter_term () :=
  {% set _active? := false} comma eof//

-- iterative range function
defun iter_range (int n1, int n2) :=
  -- readjust indexes and open iter
  | not :>iter_open? -> 
      -- iter stays closed
      | n1 = n2 -> eof
      else iter_init:n1
  | n1 < n2 -> 
      | :>iter_get = n2 - 1 -> :>iter_term
      else iter:add1
  -- n1 > n2
  else
      | :>iter_get = n2 + 1 -> :>iter_term
      else iter:sub1//


--- String funcs
--------------------------------

-- function form of the substring functionality of the index keyword
defun substring (string s, int i1, int i2) :=
  index s (i1,i2;)//

defun string_ref (string s, int i) :=
  index s i//

defun concatenate (string s1, string s2) :=
  s1 $ s2//

defun string_length (string s) :=
  length s//

-- turns the string into a list of length 1 substrings
defun string_to_list (string s) :=
  match s
  | "" -> ()
  | _ -> (index s 0), (string_to_list : (index s (1, length s;)))
  end//

-- concatenates all of the elems in the list into a single string
defun list_to_string (list ss) :=
  match ss
  | () -> ""
  | s, t -> s $ (list_to_string:t)
  end//

-- replaces all instances of target substring with rep
defun string_replace (string str, string targ, string rep) :=
  if length str < length targ then str
  else
      -- special empty string case
      | targ = "" ->
          | str = "" -> rep
          else
              rep $ str::0 $ {: string_replace 
                  | str::(1, length str;) 
                  | targ 
                  | rep}
      -- general cases
      else if 
          str::(0, length targ;) = targ
      then 
          let str2 := str::(length targ, length str;) in
             rep $ {: string_replace | str2 | targ | rep} 
      else
          -- get first char
          let c := str::0 in
          -- get rest of string
          let str2 := str::(1, length str;) in
          c $ {: string_replace | str2 | targ | rep}//
               
-- takes a string of form "~1 ~2 ~3 ~1" and turns it into "v1 v2 v3 v1"
defun format (string str, list vs) :=
  letaux format
  | str := str
  | vs := vs
  | i := 1
  in
    match vs
    | () -> str
    | v, t -> 
        let str2 := {: string_replace | str | "~" $ i | string v} in
            {: format | str2 | t | add1:i}
    end//

-- splits `str` by `sep`
defun string_split (string str, string sep) :=
  regex {list "regexp-split" | {list "quote"|sep} | str}//

-- trims whitespace from str
defun string_trim (string str) :=
  match regex_match : "^[\\s]*(.*?)[\\s]*$" : str
  | {list _ | r1} -> r1
  | false -> str
  end//

--
-- regex funcs
--
defun regex_match (string pattern, string input) :=
  regex {list "regexp-match" | {list "px"|pattern} | input}//

defun regex_match_all (string pattern, string input) :=
  regex {list "regexp-match*" | {list "px"|pattern} | input}//

defun regex_match? (string pattern, string input) :=
  regex {list "regexp-match?" | {list "px"|pattern} | input}//

defun regex_split (string pattern, string input) :=
  regex {list "regexp-split" | {list "px"|pattern} | input}//

defun regex_replace (string pattern, string input, string insert) :=
  regex {list "regexp-replace" | {list "px"|pattern} | input | insert}//

defun regex_replace_all (string pattern, string input, string insert) :=
  regex {list "regexp-replace*" | {list "px"|pattern} | input | insert}//


--- Hashmap
--------------------------------

defun list_to_hash (list ms) :=
  {: foldl 
      | lam m,h := hash_set h (`m) (~m)
      | make_hash ()
      | ms}//

defun list_to_mutable_hash (list ms) :=
  {: foldl 
      | lam m,h := (hash_set h (`m) (~m)) comma h
      | make_hash {list "mutable"}
      | ms}//


--- System
--------------------------------

-- get the current module-id dynamicaly
defun current_module () :=
  evalxp "{current_module}"//

match system_type
| "windows" -> (eval "#:def:windows{} true") comma void
| "macosx" -> (eval "#:def:macosx{} true") comma void
| "unix" -> (eval "#:def:unix{} true") comma void
| _ -> void
end//

def path_separator := 
  match system_type
  | "windows" -> "\\" 
  | _ -> "/" 
  end//

-- ("a", "b", "f.txt") -> "a/b/f.txt"
defun connect_path_elems (list elems) :=
  match elems
  | () -> ""
  | elem; -> elem 
  | elem, elems -> elem $ path_separator $ (connect_path_elems:elems)
  end//

-- "a/f.txt" -> "txt", "f" -> ""
defun get_extension (string file) :=
  match regex_match:"^.*\\.(.+)$":file
  | {list _ | r} -> r
  | false -> ""
  end//

-- "a/b/f.txt" -> ("a", "b", "f.txt";)
defun get_path_elements (string path) :=
  string_split : path : path_separator//

-- "a/b/f.txt" -> "a/b"
-- "f.txt" -> ""
defun get_path_to_file (string file) :=
  match get_path_elements:file 
  | elem; -> ""
  | elems, ..., _; -> connect_path_elems:elems
  end//

-- if `elem` ends in a path seperator, then clears
defun _clean_path_elem (string elem) :=
  match string_to_list : elem
  | () -> ""
  | cs, ..., sep; when sep = path_separator -> 
    -- recursively clean to make sure that all separators are gone
    _clean_path_elem : (list_to_string : cs)
  | _ -> elem
  end//

-- takes the list of elems and returns a string representing a connected
-- path between them
defun build_path (list elems) :=
  {: foldl
    | lambda elem, acc := 
      \| elem = "" -> acc
      \| acc = "" -> (_clean_path_elem : elem)
      else acc $ path_separator $ (_clean_path_elem : elem)
    | ""
    | elems
  }//

-- cds only if the directory exists
defun cd2 (string s) :=
  if dir_exists? s 
  then 
      cd s 
  else 
      error ("SYSTEM", ("Dir "$s$" does not exist.");)//

-- pretty print ls of current dir
defun lsc () :=
  pprint:(ls ".")//
defun cdc () :=
  (cd "")//

-- display contents of file
defun catf (string f) :=
  pprint:(getlinesf f)//

-- accesses the file-system and asks if `f` is a directory
defun directory? (string f) :=
  dir_exists? f//

defun file? (string f) :=
  file_exists? f//

-- converts the given path to its absolute form
defun expand_path (string path) :=
  to_complete_path path//

-- gives the arguments to ls with the prefix appended onto the results.
defun ls_build (string arg) :=
  {: map
    | lambda elem :=
        let arg := if system_type = "windows" then
          string_replace:arg:"/":"\\" 
          else arg 
        in
          build_path:{list arg | elem}
    | ls arg
  }//

-- recursive ls
defun ls_rec (string f) :=
  let res := ls_build : f in
    flatten:{list res |
      {: map 
      | ls_rec 
      | {: filter | directory? | res}
      }
    }//
